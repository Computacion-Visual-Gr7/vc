<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Visual Computing</title><link>https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-3/</link><description>Recent content on Visual Computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-3/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-3/FotomosaicoSoftware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-3/FotomosaicoSoftware/</guid><description>Fotomosaico por software # "</description></item><item><title/><link>https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-3/shaders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-3/shaders/</guid><description>Trabajos # photomosaic algoritm
analisis de la imagen source en este paso se busca pixelar la imagen a una resolucion determinada, se partido del fragment shader parte del ejercicio propuesto para esta seccion del curso.
fragment shader spacial coherence â†• precision mediump float; // img (image or video) is sent by the sketch uniform sampler2D img; // om is sent by the sketch uniform sampler2D om; // displays original uniform bool original; // toggles om display uniform bool om_on; // target horizontal &amp;amp; vertical resolution uniform float resolution; // interpolated color (same name and type as in vertex shader) varying vec4 vVertexColor; // interpolated texcoord (same name and type as in vertex shader) varying vec2 vTexCoord; void main() { if (original) { gl_FragColor = texture2D(img, vTexCoord); } else { // remap omCoord to [0.</description></item></channel></rss>