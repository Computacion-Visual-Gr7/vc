<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Algoritmos de visibilidad #  La determinación de las caras ocultas (HSR), en gráficos por computadores, es el proceso usado para determinar que superficies y partes de superficies son visibles o no desde algún ángulo de observación y ha sido un problema esencial desde sus inicios.
  Una variedad de algoritmos de HSR (hidden surface determination) fueron desarrollados en los años 70, para resolver el problema de la determinación de secciones visibles de los objetos en la imagen final.">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content>
<meta property="og:description" content="Algoritmos de visibilidad #  La determinación de las caras ocultas (HSR), en gráficos por computadores, es el proceso usado para determinar que superficies y partes de superficies son visibles o no desde algún ángulo de observación y ha sido un problema esencial desde sus inicios.
  Una variedad de algoritmos de HSR (hidden surface determination) fueron desarrollados en los años 70, para resolver el problema de la determinación de secciones visibles de los objetos en la imagen final.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-2/hidden-surface-determination/"><meta property="article:section" content="docs">
<meta property="article:modified_time" content="2021-12-12T22:46:01-05:00">
<title>Hidden Surface Determination | Visual Computing</title>
<link rel=manifest href=/vc/manifest.json>
<link rel=icon href=/vc/favicon.png type=image/x-icon>
<link rel=stylesheet href=/vc/book.min.89a77f7e702a8626749b948bbfb01109823daf6c1246ca407d1378833494c402.css integrity="sha256-iad/fnAqhiZ0m5SLv7ARCYI9r2wSRspAfRN4gzSUxAI=" crossorigin=anonymous>
<script defer src=/vc/flexsearch.min.js></script>
<script defer src=/vc/en.search.min.7b8b89b7206c1deb24c4c1607f44811a1d87f1f80ccb782e2fbe65f5f56c44ba.js integrity="sha256-e4uJtyBsHeskxMFgf0SBGh2H8fgMy3guL75l9fVsRLo=" crossorigin=anonymous></script>
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/vc/><span>Visual Computing</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li class=book-section-flat>
<span>Shortcodes</span>
<ul>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/buttons/>Buttons</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/columns/>Columns</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/details/>Details</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/expand/>Expand</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/hints/>Hints</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/katex/>Katex</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/mermaid/>Mermaid</a>
</li>
<li>
<input type=checkbox id=section-ec67a64aba70b9df3d2a9acd6c92e3bc class=toggle>
<label for=section-ec67a64aba70b9df3d2a9acd6c92e3bc class="flex justify-between">
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/p5/>P5</a>
</label>
<ul>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/p5/div/>Div</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/p5/iframe/>Iframe</a>
</li>
</ul>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/tabs/>Tabs</a>
</li>
<li>
<input type=checkbox id=section-5e90dfc1cda674fda3ec0abb0b45bf6a class=toggle>
<label for=section-5e90dfc1cda674fda3ec0abb0b45bf6a class="flex justify-between">
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/team/>Team</a>
</label>
<ul>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/team/Andres-Ortega/>Andres Ortega</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/team/Andres-Romero/>Andres Romero</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/team/Oscar-Mancera/>Oscar Mancera</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/team/Yerson-Valderrama/>Yerson Valderrama</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/team/Camilo-Chaparro/>Caachaparrosi</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-20b2aaf9876868d8848e886df9924bdc class=toggle checked>
<label for=section-20b2aaf9876868d8848e886df9924bdc class="flex justify-between">
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-2/>Workshop 2</a>
</label>
<ul>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-2/hidden-surface-determination/ class=active>Hidden Surface Determination</a>
</li>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop-2/rasterization/>Rasterization</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-e5d4e557e211471385c7d15285ea39e0 class=toggle>
<label for=section-e5d4e557e211471385c7d15285ea39e0 class="flex justify-between">
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop3/>Workshop3</a>
</label>
<ul>
<li>
<a href=https://computacion-visual-gr7.github.io/vc/docs/shortcodes/workshop3/shaders/>Shaders</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<a href=/vc/posts/>
Blog
</a>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/vc/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>Hidden Surface Determination</strong>
<label for=toc-control>
<img src=/vc/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#balgoritmos-de-visibilidadb><b>Algoritmos de visibilidad</b></a>
<ul>
<li>
<ul>
<li><a href=#bpainters-algorithmb><b>Painter&rsquo;s Algorithm</b></a></li>
</ul>
</li>
<li><a href=#referencias>Referencias</a></li>
</ul>
</li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h1 id=balgoritmos-de-visibilidadb>
<b>Algoritmos de visibilidad</b>
<a class=anchor href=#balgoritmos-de-visibilidadb>#</a>
</h1>
<p>La determinación de las caras ocultas (HSR), en gráficos por computadores, es el proceso usado para determinar que superficies y partes de superficies son visibles o no desde algún ángulo de observación y ha sido un problema esencial desde sus inicios.</p>
<div class=img style=display:flex;justify-content:center>
<img src=https://docs.imgtec.com/Architecture_Guides/PowerVR_Architecture/images/overdraw.jpg alt=drawing width=250>
</img>
</div>
<br>
<div class=text style=text-align:justify>
Una variedad de algoritmos de HSR (hidden surface determination) fueron desarrollados en los años 70, para resolver el problema de la determinación de secciones visibles de los objetos en la imagen final. El problema en la actualidad se considera resuelto y para la mayoría de las aplicaciones interactivas el algoritmo de selección es el: z buffer.
</div>
<p>Otro ejemplo de estos algoritmos es:</p>
<h3 id=bpainters-algorithmb>
<b>Painter&rsquo;s Algorithm</b>
<a class=anchor href=#bpainters-algorithmb>#</a>
</h3>
<div class=text style=text-align:justify>
Cuando se proyecta una escena de tres dimensiones en un plano de dos, es necesario determinar qué polígonos son visibles y cuáles no. El nombre del algoritmo se da por la analogía de un pintor que primero dibuja los elementos lejanos de una escena y después los cubre con los más cercanos. El algoritmo del pintor ordena todos los polígonos de una escena en función de su profundidad y después los pinta en ese orden, pintando encima de las partes que no son visibles y solucionando así el problema de la visibilidad.
</div>
<br>
<div class=img style=display:flex;justify-content:center>
<img src=https://upload.wikimedia.org/wikipedia/commons/8/84/Painter%27s_algorithm.png alt=drawing width=800>
</img>
</div>
<p>En términos de progamación, su pseudocódigo sería:</p>
<div class=img style=display:flex>
<img src=https://i.ibb.co/YWsgRd9/code.png width=300>
</img>
</div>
<br>
<div class=text style=text-align:justify>
La complejidad del algoritmo del pintor depende del algoritmo de ordenamiento que se utilice para organizar los polígonos. Asumiendo que se usa el algoritmo más óptimo, el peor caso para el pintor sería de <b>O(nlogn + m*n)</b>, siendo n el número de polígonos y m el número de pixeles por rellenar.
</div>
<p>EL algoritmo del pintor tiene dos grandes ventajas:</p>
<ul>
<li>Estructura gráfica básica: Su simplicidad lo vuelve muy útil en escenarios computacionales gráficos básicos donde no se requiere de renderizados sofisticados.</li>
<li>Memoria eficiente: Prioriza el uso eficiente de memoria (a costa del alto poder de procesamiento necesario para renderizar cada parte de cada imagen)</li>
</ul>
<p>Por otro lado cuenta con algunos problemas, principalmente la superposición como se muestra a continuación:</p>
<div class=img style=display:flex;justify-content:center>
<img src=https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Painters_problem.svg/800px-Painters_problem.svg.png alt=drawing width=300>
</img>
</div>
<p>Debido a que las figuras se intersecan, no es posible determinar cuál polígono está por encima de otro, de forma que para solucionarlo habría que cortar las figuras de alguna forma para su correcta ordenación.
Otra desventaja sería la ineficiencia, puesto que el sistema al tener que renderizar cada punto de cada polígono en el plano visible hace que para escenas con gran nivel de detalle el hardware sea fuertemente afectado</p>
<h2 id=referencias>
Referencias
<a class=anchor href=#referencias>#</a>
</h2>
<ul>
<li><a href=https://es.wikipedia.org/wiki/Determinaci%C3%B3n_de_cara_oculta>https://es.wikipedia.org/wiki/Determinaci%C3%B3n_de_cara_oculta</a></li>
<li><a href=https://grafica2016a.files.wordpress.com/2016/03/algoritmos-de-visibilidad.pdf>https://grafica2016a.files.wordpress.com/2016/03/algoritmos-de-visibilidad.pdf</a></li>
<li><a href=https://en.wikipedia.org/wiki/Painter%27s_algorithm>https://en.wikipedia.org/wiki/Painter%27s_algorithm</a></li>
</ul>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
<div><a class="flex align-center" href=https://github.com/Computacion-Visual-Gr7/vc/commit/a720d6b3ea3dbd30519dce7b4840601de7a10ad2 title="Last modified by caachaparrosi | December 13, 2021" target=_blank rel=noopener>
<img src=/vc/svg/calendar.svg class=book-icon alt=Calendar>
<span>December 13, 2021</span>
</a>
</div>
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#balgoritmos-de-visibilidadb><b>Algoritmos de visibilidad</b></a>
<ul>
<li>
<ul>
<li><a href=#bpainters-algorithmb><b>Painter&rsquo;s Algorithm</b></a></li>
</ul>
</li>
<li><a href=#referencias>Referencias</a></li>
</ul>
</li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>